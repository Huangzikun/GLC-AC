关键词：因子数、优化统计

思路：设$dp[i]表示“圈(circle)中除去本身之外i的因子数”$，显然$dp[i]$即为每个i对应的答案。设$cnt[i]表示“圈(circle)中i出现的次数”$，显然我们有$dp[i] = \sum_{j\in factor_i}cnt[j]$，其中$factor_i代表i的因子集合$。cnt可以通过预处理得到，于是问题的关键就在于“如何求出每个数i对应的因子集合”。

一种比较朴素的做法是

```
for(枚举i)
	for（枚举可能作为因子的j）
		if(j为因子) 将因子加入集合
```

枚举i需要执行N次操作，枚举因子至少需要执行$\sqrt i$次操作，所以总体需要执行N$\sqrt i$次操作

显然该方法不满足题目的数据要求，当取极限数据时，会TLE，因而需要考虑其他方法

注意到朴素做法的缺陷在于“不能保证每次枚举到的$(i,j)$满足 j是i的因数”

不妨反过来思考，假设k为约数，那么其倍数q显然满足$q = ak, \exist a \in N^+$

因而可以通过枚举所有可能的约数，并计算它们对应倍数的贡献从而求得$dp[i]$

具体做法如下

```
for(枚举因子i)
	for(枚举a，从而枚举倍数a * i)
		计算i对于 a * i 的贡献
```

该算法的复杂度为$O(NlogN)$，显然是可以AC哒。复杂度的证明放在下文，有兴趣的可以看看

$$
Proof \ Of  \ Complexity\\
注意到算法的时间复杂度主要集中在求每个约数的贡献部分，因而只需要分析该\\
部分的复杂度即可。\\
设S(N)表示循环上界为N时该部分的操作次数，我们有\\
S(N) = N + N / 2 + N / 3 + ... + 1= N(1 +1/2 +1/3 + ....+ 1 / N)\\
=N\sum_{i = 1}^{N} 1/i\\
由积分判别法可知\\
\sum_{i = 1}^{N} 1/i - 1 < \int_{1}^{N} 1/i \ di = \ln N\\
因而有N\sum_{i = 1}^{N} 1/i < N\ln N + N\\
于是该部分的操作次数不超过N\ln N + N，因而算法的时间复杂度为O(N\ln N)\\
证毕
$$

